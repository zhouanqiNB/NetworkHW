# 要求

实验3-2：在实验3-1的基础上，将停等机制改成基于滑动窗口的流量控制机制，采用固定窗口大小，支持累积确认，完成给定测试文件的传输。

加一下超时自动重传

# 复习一下上次我写了个什么

> 话说仅仅过去了3天吧你就需要复习了？

## 1 服务端

当服务端被运行时，它将开始监听，一旦接收到SYN报文则发送一个SYN+ACK报文；如果报文损坏，返回空报文。![image-20211204095647104](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211204095647104.png)

接着，将接收到普通文件报文。服务端接收报文，比对报文序列号是否是想要的序列号，如果是，则将expectedNum加一，返回ACK+expectedNum；如果不是或者损坏，那么不改变expectedNum，将上次的ACK报文再发一遍。

![image-20211204100102136](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211204100102136.png)

如果接收到的报文的FIN位置1，则将自己的FIN位也置一，发送回去。

![image-20211204100142430](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211204100142430.png)

## 2 客户端

当客户端被运行时，它将向服务器端发送SYN报文，直到接收到服务器的ACK才跳出循环，开始发送文件。

![image-20211204100218613](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211204100218613.png)

发送文件时，客户端发送报文之后，接收服务端的ACK，如果对方的报文是完好的，则将自己的序列号设置为对方的ACKNum；如果对方报文是损坏的，仍然发送上一次的报文。

![image-20211204100508166](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211204100508166.png)

在最后一个包发送出去的时候，给FIN置位，表示发送文件停止；接收到对方的FIN后跳出循环。

![image-20211204100618130](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211204100618130.png)

## 3 开发环境

```bash
g++ -std=c++11 client.cpp -o client.exe -lws2_32
g++ -std=c++11 server.cpp -o server.exe -lws2_32
```

随后使用以下指令可以分别运行两个程序：

```
client.exe
server.exe
```

# 总结一下问题

实验3-2：在实验3-1的基础上，将停等机制改成基于滑动窗口的流量控制机制，采用固定窗口大小，支持累积确认，完成给定测试文件的传输。

加一下超时自动重传

- 滑动窗口是什么？
- 流量控制是什么？
- 累积确认是什么意思？
- 固定窗口是什么？

# 复习一下理论课的知识

接收端==独立确认==每个正确接收的分组（而不是一次性确认i以及i之前的），必要时缓存分组，对高层==按序交付==

（每个分组独立定时）发送端只重传未收到ACK的分组

# 先加一下超时重传

我觉得在client改一下就行了，server不回复，client肯定就超时了，错误码应该是10060。但其实不是，是10054，所以我的程序疯狂重传……这个错误码的意思是： Connection closed by peer, 连接已经被对方关闭，所以还是得开一server。开server不回复就好了。

![image-20211208213929321](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211208213929321.png)

我把server的回复部分注释掉了，然后client就不停超时重传，同时server也不停地提示，接收到了SYN报文（诶，我就是不回复，就是玩儿）

![image-20211208214146499](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211208214146499.png)

![image-20211208214440808](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211208214440808.png)

# 本人的思路

首先要打印出来窗口的情况

首先窗口大小是n，做一个int a[n].

- a[i]==0：这个窗口没被占
- a[i]==1：这个窗口发了但没收到ack
- a[i]==2：发了而且收到ack了，只要左侧的都好了就可以提交并且清空内容。
- windowLeft==是window最左边的那个值的序号
- windowRight==是window最右边的那个值的序号



接收端在滑动窗口的时候把buffer提交，所以提交buffer只需要有n个。

# 看看别人怎么写的

我想不明白，那个timer怎么启动又怎么检测它是否超时，多线程吗？

## GBN-and-SRepeat-using-UDP

https://github.com/praveenganapathy19/Implementation-of-Go-Back-N-and-Selective-Repeat-protocols-using-UDP

全英文，看不懂，下一个

## Datalink-Layer-Simulation

https://github.com/mkyybx/Datalink-Layer-Simulation

很好，这是中国人写的

不好，这是学通信的人写的，下一个。

## Reliable-Data-Transfer-Protocol

https://github.com/akshaysmit/Reliable-Data-Transfer-Protocol

很好，我喜欢他的代码，另开一个文件撰写阅读笔记

# 修改自己的代码

很好已经读了别人的代码了，觉得线程这个很有意思

## 先把逻辑写到函数里

![image-20211209200556351](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211209200556351.png)

# 出现的问题

太坑了，我搞了半天多线程上锁失败原来是因为我根本没有初始化那个锁。。。

# 周五-复习一下昨天写了个啥。

好像是发送的内容出错了。

ok我看不出来哪里出的问题，重看一遍代码，重构一下。

ok我已经无语到看2进制结构了哈哈！

---

第一个包，到3839行，每行16个字节，一共61424字节，最后一个字节是00这很合理，因为这是文件名。

- 最后的字节是a100

----

写完第二个包、、、竟然就11517行了这显然是大问题。

按理来说，应该是3839*2=7678行少两位hex.

然后我发现俺的程序是这样

- 发第二个包
  - 再写一遍第一个包，再写3839行，两个a100
  - 开始写第二个包，丢了一个字节，就是上面那个00不该是00的
  - 然后最后又少了一个字节。

俺改了一下：

原来：

```c++
void move(){
    if(sendGrid[0].state==1){//如果最左侧已经ack了，需要写回。
        cout<<"move"<<endl;
        // 写数据
        fout.write
            (&sendGrid[0].buffer[HEAD_SIZE+fileNameLength],DATA_SIZE);
        //.....
```

```c++
void move(){
    if(sendGrid[0].state==1){//如果最左侧已经ack了，需要写回。
        cout<<"move"<<endl;
        // 写数据
        if(sendGrid[0].seq==0){
            fileNameLength=getter.getSize(sendGrid[0].buffer);
        }
        else{
            fileNameLength=0;
        }
        fout.write(&sendGrid[0].buffer[HEAD_SIZE+fileNameLength],DATA_SIZE-fileNameLength);
        //.....
```

这里的点是

- 第一个包不该写DATA_SIZE大小，而是DATA_SIZE-fileNameLength大小，不能把
- 除非是第一个，从文件名结束的地方开始读，否则，从开始开始读。

-----

第三个包

应该是从3839*2=7678行开始，11517结束

咱就是说这个包没问题的。

------

第四个包，大问题，11517开始，15356结束

好的莫名其妙又好了，

---

第5个包，15356开始，19195结束

----

第6个包，19195开始，23034结束

------

第7个包，23034开始，26873结束

-->转战excel拜拜了您。

# 好的现在来看看我改了什么就能跑了

## client.cpp

- 给头里加了bufferSize--为了解决接收方最后一个包末尾都是0的问题
  - 设计图
  - HEAD_SIZE+=4
  - bufferSize的类型是unsigend int
  - 添加getBufferSize
    - 这个bufferSize的设置好麻烦。
- 把sequenceNumber变成unsigned int，解决了seq跑着跑着变成负数的问题
  - sequenceNumber定义的时候
  - 头里面的setSeqNum(),setAckNum()因为要传参所以都得改，而且因为seqNum不是那么重要了，所以setSeqNum也不再需要引用而是传参就可以了----不需要在这个函数里给seq++了。
  - 同理getSeqNum(),getAckNum()，他们甚至连函数内容都要改。
- 在sendData(i)的时候，如果已经超过了序列号，就return
- 如果要发送的包的seq是最后一个，把fin标志加上。
- 每次循环清空bytesHaveWritten

所以很奇幻、、、看来client.cpp不是昨天跑不起来的罪魁祸首。

## server.cpp

- 加了bufferSize字段
- seqNum改成Unsigned int
- 在move的时候改了
  - 从哪里开始读，读多少，就是这里涉及到的bufferSize引起那么多变化。
  - 如果正要交付的那个Buffer是fin报文，那么关闭文件

> ？？？？？？？
>
> 我就改了这么点？？？？？？？？
