# 要求

实验3-2：在实验3-1的基础上，将停等机制改成基于滑动窗口的流量控制机制，采用固定窗口大小，支持累积确认，完成给定测试文件的传输。

加一下超时自动重传

# 复习一下上次我写了个什么

> 话说仅仅过去了3天吧你就需要复习了？

## 1 服务端

当服务端被运行时，它将开始监听，一旦接收到SYN报文则发送一个SYN+ACK报文；如果报文损坏，返回空报文。![image-20211204095647104](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211204095647104.png)

接着，将接收到普通文件报文。服务端接收报文，比对报文序列号是否是想要的序列号，如果是，则将expectedNum加一，返回ACK+expectedNum；如果不是或者损坏，那么不改变expectedNum，将上次的ACK报文再发一遍。

![image-20211204100102136](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211204100102136.png)

如果接收到的报文的FIN位置1，则将自己的FIN位也置一，发送回去。

![image-20211204100142430](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211204100142430.png)

## 2 客户端

当客户端被运行时，它将向服务器端发送SYN报文，直到接收到服务器的ACK才跳出循环，开始发送文件。

![image-20211204100218613](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211204100218613.png)

发送文件时，客户端发送报文之后，接收服务端的ACK，如果对方的报文是完好的，则将自己的序列号设置为对方的ACKNum；如果对方报文是损坏的，仍然发送上一次的报文。

![image-20211204100508166](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211204100508166.png)

在最后一个包发送出去的时候，给FIN置位，表示发送文件停止；接收到对方的FIN后跳出循环。

![image-20211204100618130](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211204100618130.png)

## 3 开发环境

```bash
g++ -std=c++11 client.cpp -o client.exe -lws2_32
g++ -std=c++11 server.cpp -o server.exe -lws2_32
```

随后使用以下指令可以分别运行两个程序：

```
client.exe
server.exe
```

# 总结一下问题

实验3-2：在实验3-1的基础上，将停等机制改成基于滑动窗口的流量控制机制，采用固定窗口大小，支持累积确认，完成给定测试文件的传输。

加一下超时自动重传

- 滑动窗口是什么？
- 流量控制是什么？
- 累积确认是什么意思？
- 固定窗口是什么？

# 复习一下理论课的知识

接收端==独立确认==每个正确接收的分组（而不是一次性确认i以及i之前的），必要时缓存分组，对高层==按序交付==

（每个分组独立定时）发送端只重传未收到ACK的分组

# 先加一下超时重传

我觉得在client改一下就行了，server不回复，client肯定就超时了，错误码应该是10060。但其实不是，是10054，所以我的程序疯狂重传……这个错误码的意思是： Connection closed by peer, 连接已经被对方关闭，所以还是得开一server。开server不回复就好了。

![image-20211208213929321](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211208213929321.png)

我把server的回复部分注释掉了，然后client就不停超时重传，同时server也不停地提示，接收到了SYN报文（诶，我就是不回复，就是玩儿）

![image-20211208214146499](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211208214146499.png)

![image-20211208214440808](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211208214440808.png)

# 本人的思路

首先要打印出来窗口的情况

首先窗口大小是n，做一个int a[n].

- a[i]==0：这个窗口没被占
- a[i]==1：这个窗口发了但没收到ack
- a[i]==2：发了而且收到ack了，只要左侧的都好了就可以提交并且清空内容。
- windowLeft==是window最左边的那个值的序号
- windowRight==是window最右边的那个值的序号



接收端在滑动窗口的时候把buffer提交，所以提交buffer只需要有n个。

# 看看别人怎么写的

我想不明白，那个timer怎么启动又怎么检测它是否超时，多线程吗？

## GBN-and-SRepeat-using-UDP

https://github.com/praveenganapathy19/Implementation-of-Go-Back-N-and-Selective-Repeat-protocols-using-UDP

全英文，看不懂，下一个

## Datalink-Layer-Simulation

https://github.com/mkyybx/Datalink-Layer-Simulation

很好，这是中国人写的

不好，这是学通信的人写的，下一个。

## Reliable-Data-Transfer-Protocol

https://github.com/akshaysmit/Reliable-Data-Transfer-Protocol

很好，我喜欢他的代码，另开一个文件撰写阅读笔记

# 修改自己的代码

很好已经读了别人的代码了，觉得线程这个很有意思

## 先把逻辑写到函数里

![image-20211209200556351](C:/Users/16834/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C3-2/image-20211209200556351.png)

# 出现的问题

太坑了，我搞了半天多线程上锁失败原来是因为我根本没有初始化那个锁。。。
