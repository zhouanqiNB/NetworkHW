https://github.com/akshaysmit/Reliable-Data-Transfer-Protocol

总之咱们看看这位dl是怎么写SR的呢？（以及果然开了多线程！）

俺fork了一份到自己这里，力图增加原来代码的可读性！

# 发送端

# 发送端

## send_file()

- 打开文件
- 获取文件信息
- 做头
- 开一个ack线程专门来读ack的消息
- 进入循环
  - 上锁，直到文件传完了，开锁并且跳出循环
  - 对整个窗口中的格子遍历
    - 如果这个格子已经被ack了，不做处理
    - 如果这个格子没被ACK而且timer是关着的，把它开了，发数据（有一个问题，move在哪里？---有可能在另一个线程里面。）
    - 如果这个格子的timer是开着的，看看有没有超时，如果没有，继续遍历；如果超时了，重开这个timer，开始发数据
    - 循环完了之后继续上锁
- 整个循环的唯一跳出条件就是文件已经被发完了。

> - pthread_t
>   - 这是Unix下的多线程，windows下的多线程不是这个，就是说咱还是得看多线程啊
> - pthread_create
> - pthread_detach：主线程与子线程分离，子线程结束后，资源自动回收。
> - pthread_mutex_lock：[线程](https://baike.baidu.com/item/线程/103101)调用该函数让互斥锁上锁，如果该互斥锁已被另一个线程锁定和拥有，则调用该线程将阻塞，直到该互斥锁变为可用为止。 对于 Solaris线程，请参见mutex_lock 语法。
> - pthread_mutex_unlock
> - pthread_create
> - pthread_detach

## ACKreader()

- 进入循环
  - 接收对方的包
  - 如果不是ACK包，扔掉不管
  - 如果是ACK包，锁上。遍历窗口，如果这个ack数目和里面的其中一个匹配上了，那么打印：我接到了这个ack！把那个包的ACK设置成1；如果没匹配上，开锁，继续。
  - 如果j是最左侧的格子，moveWindow.

好的主要的代码逻辑好像就是这个。

# 接收端

## get_file()

- 进入循环
  - 对SYN忽略掉
  - 如果是fin，那么把自己的也设置成fin发回去。
  - 如果notFound
  - 如果发来的是最左边的窗口
  - 如果发来的不在窗口里
  - 如果在窗口里但是不是最左边的窗口