# 实验要求

在实验3-2的基础上，选择实现一种拥塞控制算法，也可以是改进的算法，完成给定测试文件的传输。

给出实现的拥塞控制算法的原理说明。

- RENO算法；
- 也可以自行设计简单协议进行实现；
- 给出实现的拥塞控制算法的原理说明；

# 想要做的事情

- 把char数组改成指针
- 加上一个拥塞控制算法

# 开发环境

```bash
g++ -std=c++11 client.cpp -o client.exe -lws2_32
g++ -std=c++11 server.cpp -o server.exe -lws2_32
```

随后使用以下指令可以分别运行两个程序：

```
client.exe
server.exe
```

# 图表的思路

先把数据存储在txt里面然后用python跑。

# RENO算法是什么

假设：

- 丢包是因为网络出现拥塞导致的
- 网络的RTT和带宽是稳定不容易变化的

> 这玩意老子实现不了，滚吧。

# 把char数组改成指针

这个不难，只是在挪窗口的时候把第0个窗口delete掉，然后把最后一个窗口的指针指向null就可以了。

# 我自己设计的算法

我加在头里加一个位，如果接收窗口里超过半数的在堵着，那么给发送端发一个重传的要求。（发送端的定时器还没有过期）



# TCP拥塞控制

防止过多的数据注入到网络中

流量控制是点到点的，拥塞控制是网络的全局问题

- 接收方可以感受到网络的拥塞

# 多少算是超时

我把超时重传的时间从1秒改成了0.1秒，立刻跑得贼快。
